# Find Unused

This is a Scala 3 tool to find unused code. It uses the TASTy files generated by the compiler and
[tasty-query](https://github.com/scalacenter/tasty-query) to determine what code is used/unused.

See below for more details on setup and use.

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [Install and configure](#install-and-configure)
  - [sbt plugin](#sbt-plugin)
  - [Standalone CLI](#standalone-cli)
- [Usage](#usage)
  - [sbt plugin](#sbt-plugin-1)
  - [Standalone CLI](#standalone-cli-1)
- [Known issues](#known-issues)
  - [`given`s/`implicit`s summoned with `inline`/macro methods](#givensimplicits-summoned-with-inlinemacro-methods)
  - [Lack of support for multiple Scala versions](#lack-of-support-for-multiple-scala-versions)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## Install and configure

### sbt plugin

To install the tool in an sbt project, add this to `project/plugins.sbt`, using the version number from the latest
GitHub release:

![GitHub Release](https://img.shields.io/github/v/release/mblink/find-unused)

```scala
resolvers += "bondlink-maven-repo" at "https://maven.bondlink-cdn.com"
addSbtPlugin("bondlink" % "find-unused" % "x.y.z")
```

Then update `build.sbt` to specify which top-level packages should be analyzed for unused code:

```scala
Global / findUnusedPackages := Seq("foo", "bar")
```

### Standalone CLI

To install the tool as a standalone CLI, download `find-unused.jar` from
[the latest GitHub release](https://github.com/mblink/find-unused/releases/latest).

## Usage

### sbt plugin

A few sbt commands are available:

|Command|Description|
|---|---|
|`findUnusedExplicits`|Analyze the configured packages for unused explicit (i.e. non-implicit/given/using) code|
|`findUnusedGivens`|Analyze the configured packages for unused implicit/given/using code|
|`findUnusedImplicits`|An alias for `findUnusedGivens`|
|`findUnusedAll`|Analyze the configured packages for all types of unused code|

### Standalone CLI

You can run the standalone CLI with:

```bash
java -jar /path/to/find-unused.jar
```

TODO - describe what needs to be passed for each command.

## Known issues

### `given`s/`implicit`s summoned with `inline`/macro methods

As of Scala 3.6.4, the TASTy representation of some `inline` and macro-related methods does not include references to
the `given`/`implicit` instances that they summon -- https://github.com/scala/scala3/issues/22701

This includes:

1. `scala.compiletime.summonAll`
2. `scala.compiletime.summonFrom`
3. `scala.quoted.Expr.summon`
4. Uses of `scala.compiletime.summonInline` in macros

The end result is that any instances that are _only_ resolved by these methods will be reported as unused.

This is especially problematic for derivation, which often uses `summonFrom`. For example, with this code using
[circe](https://github.com/circe/circe) derivation:

```scala
import io.circe.Decoder

case class Foo(int: Int) derives Decoder
case class Bar(foo: Foo) derives Decoder
```

`Foo`'s derived `Decoder` will be reported as unused because circe derivation uses `summonFrom`. The `Decoder` is
required and used by `Bar`'s derived `Decoder`.

### `transparent inline` methods

As of Scala 3.6.4, the TASTy representation of calls to `transparent inline` methods is equivalent to the TASTy
representation of the body of the `transparent inline` method -- there is no indication that the `transparent inline`
method was called.

For example:

```scala
transparent inline def foo(): Int = 1
val bar = foo()
```

The TASTy representation for `val bar` does not include a reference to `transparent inline def foo`, it appears as if
`val bar` is simply defined as

```scala
val bar = 1
```

The end result is that `transparent inline def`s are reported as unused even when they are in fact used.

### Lack of support for multiple Scala versions

At the moment this tool only works when all projects in your build use the same Scala version, and that version is
Scala 3.6.x.

Support may be added in the future for multiple Scala versions within the same build or for older Scala 3 versions.
